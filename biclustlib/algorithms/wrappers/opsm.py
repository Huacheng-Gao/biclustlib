"""
    biclustlib: A Python library of biclustering algorithms and evaluation measures.
    Copyright (C) 2017  Victor Alexandre Padilha

    This file is part of biclustlib.

    biclustlib is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    biclustlib is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
"""

from ._base import ExecutableWrapper
from os.path import dirname, join
from ...models import Bicluster, Biclustering

import os
import numpy as np

class OrderPreservingSubMatrix(ExecutableWrapper):
    """Order-Preserving SubMatrix (OPSM)

    OPSM finds biclusters, each one containing rows that follow the same order under the
    bicluster columns.

    This class is a simple wrapper for part of the BicAT software (http://people.ee.ethz.ch/~sop/bicat/).

    Reference
    ---------
    Ben-Dor, A., Chor, B., Karp, R., and Yakhini, Z. (2003). Discovering local structure in gene expression
    data: the order-preserving submatrix problem. Journal of computational biology, 10(3-4), 373-384.

    Parameters
    ----------
    num_best_partial_models : int, default: 100
        Number of best partial models to maintain from one iteration to another.

    tmp_dir : str, default: '.opsm_tmp'
        Temporary directory to save the outputs generated by OPSM's jar.
    """

    def __init__(self, num_best_partial_models=100, tmp_dir='.opsm_tmp'):
        module_dir = dirname(__file__)

        exec_comm = 'java -jar ' + \
                    join(module_dir, 'jar', 'OPSM.jar') + \
                    ' {_data_filename}' + \
                    ' {_num_rows}' + \
                    ' {_num_cols}' + \
                    ' {_output_filename}' + \
                    ' {num_best_partial_models}'

        super().__init__(exec_comm, tmp_dir=tmp_dir)

        self.num_best_partial_models = num_best_partial_models
        self._num_rows = None
        self._num_cols = None

    def _write_data(self, data):
        self._num_rows, self._num_cols = data.shape
        super()._write_data(data, header=False, row_names=False)

    def _parse_output(self):
        biclusters = []

        if os.path.exists(self._output_filename):
            with open(self._output_filename, 'r') as f:
                all_lines = f.readlines()
                chunk = 3

                for i in range(0, len(all_lines), chunk):
                    rows, cols, _ = all_lines[i:i + chunk]
                    rows = self._convert(rows)
                    cols = self._convert(cols)
                    biclusters.append(Bicluster(rows, cols))

        return Biclustering(biclusters)

    def _convert(self, str_array):
        return np.array([int(n) for n in str_array.rstrip().split()])

    def _validate_parameters(self):
        if self.num_best_partial_models <= 0:
            raise ValueError('num_best_partial_models must be > 0, got {}'.format(self.num_best_partial_models))
